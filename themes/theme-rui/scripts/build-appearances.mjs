#!/usr/bin/env node
/**
 * Scans theme component style files and generates src/appearances.ts
 * with variant/size keys per component. Used by docs for AppearanceTable.
 */
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const themeRoot = path.join(__dirname, '..');
const componentsDir = path.join(themeRoot, 'src', 'components');

/**
 * Find matching closing brace; start at content[i] (after opening {).
 * Returns end index (exclusive).
 */
function findBlockEnd(content, startIndex) {
  let depth = 1;
  let i = startIndex;
  while (i < content.length && depth > 0) {
    const ch = content[i];
    if (ch === '{') depth++;
    else if (ch === '}') depth--;
    i++;
  }
  return i;
}

// Keys that are cva/config internals or state names, not variant/size option names
const SKIP_KEYS = new Set([
  'class',
  'variant',
  'size',
  'variants',
  'defaultVariants',
  'compoundVariants',
  'expanded',
  'hover',
  'pending',
  'disabled',
  'focus',
  'focus-visible',
  'in-first',
  'not-last',
  'first-child',
  'last',
  'dragging',
  'selected',
  'marker',
  'td',
  'tr',
  'grid',
  'muted',
  'fit',
  'inverted',
  'data-large',
  'data-medium',
  'data-small',
  'data-selection-mode',
  'cell-x-padding',
  'cell-y-padding',
  'header-height',
  'dialog-width',
  'placement-bottom',
  'placement-left',
  'placement-right',
  'placement-top',
]);

/**
 * Extract keys from a block like { primary: ..., secondary: ... }.
 * Only match keys at line start (with optional indent) to avoid capturing
 * "key: value" inside string values. Skip known config/keyword keys.
 */
function extractKeys(blockContent) {
  const keys = new Set();
  const lines = blockContent.split('\n');
  for (const line of lines) {
    const m = line.match(/^\s*'?([a-zA-Z][a-zA-Z0-9-]*)'?\s*:/);
    if (m && !SKIP_KEYS.has(m[1])) keys.add(m[1]);
  }
  return [...keys];
}

/**
 * Find all "variant: {" or "size: {" blocks in content and collect keys.
 */
function collectVariantSizeKeys(content) {
  const variants = new Set();
  const sizes = new Set();
  const variantMarker = 'variant:';
  const sizeMarker = 'size:';

  let idx = 0;
  while (idx < content.length) {
    const vPos = content.indexOf(variantMarker, idx);
    const sPos = content.indexOf(sizeMarker, idx);

    let nextPos = content.length;
    if (vPos !== -1) nextPos = Math.min(nextPos, vPos);
    if (sPos !== -1) nextPos = Math.min(nextPos, sPos);
    if (nextPos === content.length) break;

    if (vPos !== -1 && vPos === nextPos) {
      const afterMarker = content.slice(vPos + variantMarker.length);
      const openBrace = afterMarker.indexOf('{');
      if (openBrace !== -1) {
        const blockStart = vPos + variantMarker.length + openBrace + 1;
        const blockEnd = findBlockEnd(content, blockStart);
        const block = content.slice(blockStart, blockEnd - 1);
        extractKeys(block).forEach(k => variants.add(k));
      }
      idx = vPos + 1;
    } else if (sPos !== -1 && sPos === nextPos) {
      const afterMarker = content.slice(sPos + sizeMarker.length);
      const openBrace = afterMarker.indexOf('{');
      if (openBrace !== -1) {
        const blockStart = sPos + sizeMarker.length + openBrace + 1;
        const blockEnd = findBlockEnd(content, blockStart);
        const block = content.slice(blockStart, blockEnd - 1);
        extractKeys(block).forEach(k => sizes.add(k));
      }
      idx = sPos + 1;
    } else {
      idx = nextPos + 1;
    }
  }

  return { variant: [...variants].sort(), size: [...sizes].sort() };
}

/**
 * Get component name from "export const ComponentName: ThemeComponent..."
 */
function getComponentName(content) {
  const m = content.match(
    /export\s+const\s+([A-Za-z0-9]+)\s*:\s*ThemeComponent/
  );
  return m ? m[1] : null;
}

function buildAppearances() {
  if (!fs.existsSync(componentsDir)) {
    console.error('Components dir not found:', componentsDir);
    process.exit(1);
  }

  const files = fs
    .readdirSync(componentsDir)
    .filter(f => f.endsWith('.styles.ts'));
  const appearances = {};

  for (const file of files) {
    const filePath = path.join(componentsDir, file);
    const content = fs.readFileSync(filePath, 'utf8');
    const name = getComponentName(content);
    if (!name) continue;

    const { variant, size } = collectVariantSizeKeys(content);
    if (variant.length > 0 || size.length > 0) {
      appearances[name] = { variant, size };
    }
  }

  const outPath = path.join(themeRoot, 'src', 'appearances.ts');
  const lines = [
    '/**',
    ' * Component appearances (variant/size keys) for themed components.',
    ' * Auto-generated by scripts/build-appearances.mjs. Do not edit by hand.',
    ' */',
    'export type Appearances = Record<string, { variant: string[]; size: string[] }>;',
    '',
    'export const appearances: Appearances = {',
    ...Object.entries(appearances)
      .sort(([a], [b]) => a.localeCompare(b))
      .map(
        ([comp, { variant, size }]) =>
          `  ${comp}: { variant: ${JSON.stringify(variant)}, size: ${JSON.stringify(size)} },`
      ),
    '};',
    '',
  ];
  fs.writeFileSync(outPath, lines.join('\n'), 'utf8');
  console.log(
    'Generated',
    outPath,
    'with',
    Object.keys(appearances).length,
    'components'
  );

  // In monorepo, also write docs registry so docs can show variant/size tables
  const docsRegistry = path.join(
    themeRoot,
    '..',
    '..',
    'docs',
    '.registry',
    'appearances.json'
  );
  if (fs.existsSync(path.dirname(docsRegistry))) {
    fs.writeFileSync(
      docsRegistry,
      JSON.stringify(appearances, null, 2),
      'utf8'
    );
    console.log('Updated', docsRegistry);
  }
}

buildAppearances();
