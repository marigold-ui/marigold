// @ts-check
import { readFile, readdir, writeFile } from 'node:fs/promises';
import { createRequire } from 'node:module';
import { basename, join, resolve } from 'node:path';
import { fileURLToPath } from 'node:url';

const require = createRequire(import.meta.url);
const ts = require('typescript');

const __dirname = fileURLToPath(new URL('.', import.meta.url));

console.log('ðŸŽ¨ Generating appearances data...');

/**
 * Components that share styles with another component.
 * Key = component name in docs, Value = component name in theme.
 */
const sharedAppearances = {
  LinkButton: 'Button',
  ToggleButtonGroup: 'ToggleButton',
};

/**
 * Extract property name keys from a `variants` object literal in a cva() call.
 * Returns `{ variant: string[], size: string[] }`.
 */
function extractVariantKeys(cvaArg) {
  if (!cvaArg || !ts.isObjectLiteralExpression(cvaArg)) {
    return { variant: [], size: [] };
  }

  const variantProp = cvaArg.properties.find(
    p => ts.isPropertyAssignment(p) && p.name.getText() === 'variants'
  );

  if (
    !variantProp ||
    !ts.isPropertyAssignment(variantProp) ||
    !ts.isObjectLiteralExpression(variantProp.initializer)
  ) {
    return { variant: [], size: [] };
  }

  const result = { variant: [], size: [] };

  for (const prop of variantProp.initializer.properties) {
    if (!ts.isPropertyAssignment(prop)) continue;
    const name = prop.name.getText();
    if (name !== 'variant' && name !== 'size') continue;

    if (ts.isObjectLiteralExpression(prop.initializer)) {
      result[name] = prop.initializer.properties
        .filter(p => ts.isPropertyAssignment(p))
        .map(p => {
          const keyNode = p.name;
          if (ts.isStringLiteral(keyNode)) return keyNode.text;
          if (ts.isComputedPropertyName(keyNode)) return keyNode.getText();
          return keyNode.getText();
        });
    }
  }

  return result;
}

/**
 * Find all cva() call expressions in a node (recursively).
 */
function findCvaCalls(node) {
  const calls = [];
  function visit(n) {
    if (
      ts.isCallExpression(n) &&
      ts.isIdentifier(n.expression) &&
      n.expression.text === 'cva'
    ) {
      calls.push(n);
    }
    ts.forEachChild(n, visit);
  }
  visit(node);
  return calls;
}

async function main() {
  const stylesDir = resolve(__dirname, '../src/components');
  const dirEntries = await readdir(stylesDir);
  const files = dirEntries
    .filter(f => f.endsWith('.styles.ts'))
    .map(f => join(stylesDir, f));

  /** @type {Record<string, { variant: string[], size: string[] }>} */
  const appearances = {};

  for (const filePath of files) {
    const source = await readFile(filePath, 'utf-8');
    const sourceFile = ts.createSourceFile(
      basename(filePath),
      source,
      ts.ScriptTarget.Latest,
      true
    );

    // Find exported variable declarations (e.g. `export const Button = ...`)
    for (const stmt of sourceFile.statements) {
      if (
        !ts.isVariableStatement(stmt) ||
        !stmt.modifiers?.some(m => m.kind === ts.SyntaxKind.ExportKeyword)
      ) {
        continue;
      }

      for (const decl of stmt.declarationList.declarations) {
        if (!ts.isIdentifier(decl.name) || !decl.initializer) continue;
        const componentName = decl.name.text;

        // Skip non-component exports (e.g. `buttonBase`)
        if (componentName[0] !== componentName[0].toUpperCase()) continue;

        if (ts.isCallExpression(decl.initializer)) {
          // Single-slot: export const X = cva({...})
          const arg = decl.initializer.arguments[0];
          appearances[componentName] = extractVariantKeys(arg);
        } else if (ts.isObjectLiteralExpression(decl.initializer)) {
          // Multi-slot: export const X = { slot: cva({...}), ... }
          const variantKeys = new Set();
          const sizeKeys = new Set();

          const cvaCalls = findCvaCalls(decl.initializer);
          for (const call of cvaCalls) {
            const keys = extractVariantKeys(call.arguments[0]);
            for (const k of keys.variant) variantKeys.add(k);
            for (const k of keys.size) sizeKeys.add(k);
          }

          appearances[componentName] = {
            variant: [...variantKeys],
            size: [...sizeKeys],
          };
        }
      }
    }
  }

  // Add shared appearances (components that reuse another component's styles)
  for (const [alias, target] of Object.entries(sharedAppearances)) {
    if (appearances[target]) {
      appearances[alias] = appearances[target];
    }
  }

  // Generate TypeScript source file
  const lines = [
    '// Auto-generated by scripts/build-appearances.mjs â€” DO NOT EDIT',
    "// Run 'pnpm build' in themes/theme-rui to regenerate.",
    '',
    'export const appearances = {',
  ];

  for (const [name, { variant, size }] of Object.entries(appearances).sort(
    ([a], [b]) => a.localeCompare(b)
  )) {
    lines.push(`  ${name}: {`);
    lines.push(
      `    variant: [${variant.map(v => JSON.stringify(v)).join(', ')}],`
    );
    lines.push(`    size: [${size.map(s => JSON.stringify(s)).join(', ')}],`);
    lines.push(`  },`);
  }

  lines.push(
    '} as const;',
    '',
    'export type Appearances = typeof appearances;',
    ''
  );

  const outFile = resolve(__dirname, '../src/appearances.ts');
  await writeFile(outFile, lines.join('\n'), 'utf-8');

  console.log(
    `âœ… Generated appearances for ${Object.keys(appearances).length} components â†’ src/appearances.ts`
  );
}

main().catch(err => {
  console.error('Failed to generate appearances:', err);
  process.exit(1);
});
