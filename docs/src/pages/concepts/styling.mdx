---
title: Styling
caption: Learn about the theme object and styling in Marigold.
---

Marigold strictly separates the logic of components from their appearance. By default, every component comes with only basic styling that mostly serves to normalize the appearance between browsers. The main concern of a component is to manage its logic and accessibility features associated with its use case.

To give components a certain appearance, we use what are called "themes." Themes are the other half of the equation, as they contain all design tokens and define which styles are applied to a certain component.

This separation enables styling of components to extend beyond just changing design tokens. With Marigold themes, full control over the CSS of each component is allowed, enabling them to be perfectly adjusted and fitted to a corporate identity.

The upcoming sections will explain how themes are constructed, and how design tokens can be used to style components. To learn more about how to apply an existing theme in Marigold, visit the [theming page](/introduction/theming/).

## Theme Specification

Marigold's themes are based on the [Styled System Theme Specification](https://styled-system.com/theme-specification/). This ensures that themes created for Marigold are suitable for white-label applications and general-purpose theming.

The theme is represented as a plain object (JSON) and consists of the following data types:

- _Tokens:_ plain objects or arrays of values that for related CSS properties
- _Breakpoints:_ array of values (preferably using the `em` unit) that define the breakpoints for responsvie style values
- _Root:_ plain object that contains styles with are applied to the root of an app using Marigold
- _Component styles:_ a collection of styles for each Marigold component

### Tokens

The theme object is made up of the following tokens (i.e. property-specific objects) for use in CSS styles.

<Table variant="lines" aria-label="List of theme tokens">
  <Table.Header>
    <Table.Column>Token Name</Table.Column>
    <Table.Column>CSS Properties</Table.Column>
  </Table.Header>
  <Table.Body>
    <Table.Row>
      <Table.Cell>
        <strong>colors</strong>
      </Table.Cell>
      <Table.Cell>
        color, background, background-color, border-color, caret-color,
        column-rule-color, outline-color, text-decoration-color,
        border-top-color, border-bottom-color, border-left-color,
        border-right-color, border-block-color, border-block-end-color,
        border-block-start-color, border-inline-color, border-inline-end-color,
        border-inline-start-color, fill, stroke
      </Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>
        <strong>space</strong>
      </Table.Cell>
      <Table.Cell>
        margin, margin-top, margin-right, margin-bottom, margin-left,
        margin-block, margin-block-end, margin-block-start, margin-inline,
        margin-inline-end, margin-inline-start, padding, padding-top,
        padding-right, padding-bottom, padding-left, padding-block,
        padding-block-end, padding-block-start, padding-inline,
        padding-inline-end, padding-inline-start, scroll-margin,
        scroll-margin-top, scroll-margin-right, scroll-margin-bottom,
        scroll-margin-left, scroll-padding, scroll-padding-top,
        scroll-padding-right, scroll-padding-bottom, scroll-padding-left, inset,
        inset-block, inset-block-end, inset-block-start, inset-inline,
        inset-inline-end, inset-inline-start, top, right, bottom, left,
        grid-gap, grid-column-gap, grid-row-gap, gap, column-gap, row-gap
      </Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>
        <strong>fonts</strong>
      </Table.Cell>
      <Table.Cell>font-family</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>
        <strong>fontSizes</strong>
      </Table.Cell>
      <Table.Cell>font-size</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>
        <strong>fontWeights</strong>
      </Table.Cell>
      <Table.Cell>font-weight</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>
        <strong>letterSpacings</strong>
      </Table.Cell>
      <Table.Cell>letter-spacing</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>
        <strong>lineHeights</strong>
      </Table.Cell>
      <Table.Cell>line-height</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>
        <strong>sizes</strong>
      </Table.Cell>
      <Table.Cell>
        width, min-width, max-width, height, min-height, max-height, flex-basis,
        block-size, inline-size, max-block-size, max-inline-size,
        min-block-size, min-inline-size, column-width
      </Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>
        <strong>borders</strong>
      </Table.Cell>
      <Table.Cell>
        border, border-top, border-right, border-bottom, border-left,
        border-block, border-block-end, border-block-start, border-inline,
        border-inline-end, border-inline-start
      </Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>
        <strong>borderStyles</strong>
      </Table.Cell>
      <Table.Cell>
        border-style, border-top-style, border-bottom-style, border-left-style,
        border-right-style, border-block-end-style, border-block-start-style,
        border-block-style, border-inline-end-style, border-inline-start-style,
        border-inline-style
      </Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>
        <strong>borderWidths</strong>
      </Table.Cell>
      <Table.Cell>
        border-width, border-top-width, border-bottom-width, border-left-width,
        border-right-width, border-block-end-width, border-block-start-width,
        border-block-width, border-inline-end-width, border-inline-start-width,
        border-inline-width, column-rule-width
      </Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>
        <strong>radii</strong>
      </Table.Cell>
      <Table.Cell>
        border-radius, border-top-right-radius, border-top-left-radius,
        border-bottom-right-radius, border-bottom-left-radius,
        border-end-end-radius, border-end-start-radius, border-start-end-radius,
        border-start-start-radius
      </Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>
        <strong>shadows</strong>
      </Table.Cell>
      <Table.Cell>box-shadow, text-shadow</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>
        <strong>zIndices</strong>
      </Table.Cell>
      <Table.Cell>z-index</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>
        <strong>opacities</strong>
      </Table.Cell>
      <Table.Cell>opacity</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>
        <strong>transitions</strong>
      </Table.Cell>
      <Table.Cell>transition</Table.Cell>
    </Table.Row>
  </Table.Body>
</Table>

Tokens should be preferred when writing CSS styles. Below you can see how tokens from a theme are used to style a component. The `<Box>` uses the token values and Marigold will take care to replace the tokens with their corresponding value.

```tsx preview file=concepts/tokens.demo.tsx

```

### Breakpoints

Breakpoints can be used to apply [responsive styles](#responsive-styles). Each breakpoint should be a string that includes a CSS length unit, or a string that includes a CSS media query. String values that include a CSS length unit will be used to generate a mobile-first media query (i.e. a `min-width` media query).

```ts
const theme = {
  breakpoints: [
    '40em',
    '@media (min-width: 56em) and (orientation: landscape)',
    '64em',
  ],
};
```

### Root (Styles)

The `root` property of the theme object can be used when global styles have to be applied, including normalization of `body` and `html`. Styles can use tokens from the theme and arbitrary CSS selectors can be used.

```ts
const theme = {
  colors: {
    background: '#e2e8f0',
    text: '#0f172a',
  },
  fonts: {
    body: ' ui-sans-serif, system-ui, "Segoe UI", Roboto, Arial, sans-serif',
  },
  root: {
    body: {
      margin: 0,
      padding: 0,
      fontFamily: 'body',
      color: 'text',
      bg: 'background',
    },
  },
};
```

### Component Styles

Writing component styles in a maintainable way, especially over the life of a growing and changing project is a challenging task. To adress this, we use a approach inspired by [Chakra UI](https://chakra-ui.com/) that allows us to use a consistent API to describe component styling, while beeing easy to understand and maintain.

Each component style consists of the following sections:

- `base`: a default style for the component that is always applied
- `variant`: a component can have different visual appearances (e.g. primary, secondary, ...) that will override the `base` styles
- `size`: a component can have differenz sizes (e.g. small, medium, large) that will override the `base` styles

Some components only consist of one functional unit to fulfill their purpose. For example, to create a button you only need a `<button>` element. However, there are component that are composed of multiple parts. Using a cell (`<td>`) outside of a table (`<table>`) does neither make any sense nor is it valid HTML.

```tsx
<Button>Click me!</Button>
```

```tsx
<Table>
  <Table.Header>
    <Table.Column>Name</Table.Column>
    <Table.Column>Firstname</Table.Column>
  </Table.Header>
  <Table.Body>
    <Table.Row>
      <Table.Cell>Potter</Table.Cell>
      <Table.Cell>Harry</Table.Cell>
    </Table.Row>
    <Table.Row>
      <Table.Cell>Malfoy</Table.Cell>
      <Table.Cell>Draco</Table.Cell>
    </Table.Row>
  </Table.Body>
</Table>
```

This means that even [atomic components](https://atomicdesign.bradfrost.com/chapter-2) can be made up of multiple (smaller) parts. An atom only describes the smallest possible functional unit that can not be broken down further without losing its meaning. In React this is commonly referred to as a composite component. For this reason, Marigold's component styles allow to specify the appearance of each part inside the `base`, `variant` and `size` sections.

The full breakdown of how styling a component works and how they work together with themes, can be found in the "[Theming Components](#theming-components)" section down below.

## Responsive Styles

Marigold, like Styled System, includes a shorthand syntax for writing mobile-first responsive styles using arrays as values. This is useful when you want to change a single property across multiple breakpoints without needing to write verbose media query syntax. Responsive styles can be used whenever you specify a CSS rule and, of course, tokens can be used too.

The `Component` in the following example uses responsive styles for its `width`. With responsive arrays, the 0-th element maps to all breakpoints, and the n-th element maps to the (n - 1)-th breakpoint. This means:

- The default width is 100%
- At the 0th breakpoint & larger, width is `large` (`theme.sizes.large`)
- At the 1st breakpoint & larger, width is `small` (`theme.sizes.small`)

```tsx
export const Component = () => (
  <Box
    css={{
      width: ['100%', 'large', 'small'],
    }}
  >
    I am a reposnsive Box!
  </Box>
);
```

If you want to skip a breakpoint, you can use `null` as placeholder value. This is useful if you want to set a value for only the largest breakpoint, for example.

```tsx
export const Component = () => (
  <Box
    css={{
      width: ['100%', null, 'small'],
    }}
  >
    I am a reposnsive Box!
  </Box>
);
```

## Styling Components

As mentioned before, Marigold uses a specific format to define the appearancesce of components. It consists of the `base`, `variant` and `size` (see [Component Styles](#component-styles)). The most basic API for styling a component looks like this:

```ts
// Single part styles for a <Button>
export const Button = {
  // Styles for the default appearance
  base: {},
  // Styles for the visual style variations
  variant: {},
  // Styles for the size variations
  size: {},
};
```

Following this format you can style Marigold's component (with the exception of [layout components](/concepts/layouts/)). Styles will be scoped to the component. They will not leak into any other component.

As you can see in the following example styling the `<Button>` component, the `base` styles are always applied. `variant` and `size` can be added via the corresponding props of the `<Button>`. Adding these two props is optional, since every component has at least one base appearance.

```tsx preview file=concepts/simple-styling.demo.tsx

```

There are components which are more complex than a button, a table for example. They consist of more than one part. Every table has cells, rows, a body for example. With some additional parts like a header.

Marigold's styling solution also allows to handle styling of complex component, which internally have more than one part. Similar to a single part component, the format uses `base`, `variant` and `size`. The parts of a component (`header`, `row`, `cell`) are the child props of `base`, `variant` and `size`. Styling is then applied like with a single component. The parts will always have their base style and in addition, can have a `variant` and/or a `size`.

The `variant` and `size` props are usually added on the top most component (`<Table>`) and will then be passed down to their children. For example, if you want collapsed rows add the variant to the table, `<Table variant="collapse">`. These composite components usually share variants and sizes between parts so that the different parts work well together.

```ts
// Single multi part styles for a <Table>
export const Table = {
  // Styles for the default appearance
  base: {
    // <Table.Header>
    header: {},
    // <Table.Row>
    row: {},
    // <Table.Cell>
    cell: {},
  },
  // Styles for the visual style variations
  variant: {
    head: {},
    row: {},
    cell: {
      // <Table.Cell variant="collapsed">
      collapsed: {},
    },
  },
  // Styles for the size variations
  size: {
    head: {
      // <Table.Header size="large">
      large: {},
    },
    row: {},
    cell: {},
  },
};
```

### Using the "useComponentStyles" hook

Since we use a unified API, Marigold has a hook to simplify the consumption and application of component styles called `useComponentStyles`. Passing in the component name, variant and size will return the computed styles for the specified component. For applying the styles the `<Box>` in conjunction with its `css` prop can be used.

```tsx
import { ReactNode } from 'react';
import { Box, useComponentStyles } from '@marigold/system';

interface CardProps {
  variant?: string;
  size?: string;
  children?: ReactNode;
}

const Card = ({ variant, size, children }: CardProps) => {
  // Get styles for a component based on component name, variant + size.
  const styles = useComponentStyles('Card', { variant, size });
  // Pass the computed styles into the `css` prop
  return <Box css={styles}>{children}</Box>;
};
```

Components with multiple parts can be handled by the `useComponentStyles` too. Parts can be specified in the third parameter, like shown in the example below. Insteas of a single styles object, the `useComponentStyles` hook will return an object with all parts which then can be passed to the composite component parts.

```tsx
/**
 *  styles = {
 *    table: CSSObject,
 *    header: CSSObject,
 *    row: CSSObject,
 *    cell: CSSObject,
 *  }
 */
const styles = useComponentStyles(
  'Card',
  { variant, size },
  { parts: ['table', 'header', 'row', 'cell'] }
);
```

Generating these styles once will lead to less runtime overhead. They can be passed down via context or prop drilling.
