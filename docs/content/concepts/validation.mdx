---
title: Validation
caption: Learn about how to use form validation with Marigold.
badge: new
---

HTML forms enable the collection and submission of user input on web pages. Form elements also support validation of those inputs through attributes like "required" and input types such as "email" or "number" to provide users with feedback.

Marigold's components seamlessly integrate with HTML forms, providing a developer-friendly solution for effective input data validation. It supports native attributes such as "required" and validation based on input types. Furthermore, Marigold's form elements enable the incorporation of custom validation functions, enhancing the browser's validation capabilities.

## Field Anatomy

An accessible form input includes a clear label associated with its corresponding form control (`<input>`, `<select>`, ...). Additional guidance is provided by a help text, which can give additional context or instructions or display a descriptive messages.

<Image
  src="/field.png"
  alt="Anatomy of a field"
  width={300}
  height={150}
  className="mx-auto block"
/>

Marigold's form components allow to set these properties like shown below. All form components allow to set a `label`, `description` and `errorMessages` besides some additional control-specific props.

```tsx
<TextField
  label="Promo Code"
  description="You can find the code on the back of your ticket."
  errorMessage="The promo code was already used."
/>
```

## Forms and submitting Data

In HTML, forms are build using the `<form>` element, which wraps a set of input fields to gather and submit user data. By default, HTML forms trigger a full-page refresh upon submission. To gain control over the process, you can use preventDefault during the onSubmit event, enabling you to make a custom API call to submit the data according to your preferences.

The simplest way to get data from a form is using the browser's [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData) API during the `onSubmit` event. This can be passed directly to `fetch`, or converted into a regular JavaScript object using `Object.fromEntries`.

<Message messageTitle="Names are important!" variant="info">
  Make sure to include the name attribute in each field, as it uniquely
  identifies each form element, facilitating server-side processing and ensuring
  a key-value pair for data submission.
</Message>

Here is a simple example of retrieving data from an [uncontrolled](https://react.dev/learn/sharing-state-between-components#controlled-and-uncontrolled-components) form:

<ComponentDemo file="./validation-submit.demo.tsx" />

## Built-in Form Validation

The most straightforward way to check user input is to use the built-in validation called [constraint validation](https://developer.mozilla.org/en-US/docs/Web/HTML/Constraint_validation).

Marigold's form components work seamlessly with this API, allowing you to set constraints for each field like making it required, allowing a certain minimum and maximum values, and specific text formats (e.g., email addresses). These constraints get checked by the browser on blur or when the user submits the form.

<ComponentDemo file="./validation-base.demo.tsx" />

### Custom Message

custom message falls back to native!

<ComponentDemo file="./validation-custom-message.demo.tsx" />

### Custom Validation

<ComponentDemo file="./validation-custom-validation.demo.tsx" />

### Realtime Validation

<ComponentDemo file="./validation-realtime.demo.tsx" />

### Very large example

<ComponentDemo file="./validation-built-in.demo.tsx" />
