#!/usr/bin/env node
// Registry of demos - scans content folder for *.demo.tsx files
// and generates a registry file with dynamic imports and source code
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const rootDir = path.join(__dirname, '..');

/**
 * Recursively find all *.demo.tsx files in a directory
 */
function findDemoFiles(dir, fileList = []) {
  const files = fs.readdirSync(dir);

  files.forEach(file => {
    const filePath = path.join(dir, file);
    const stat = fs.statSync(filePath);

    if (stat.isDirectory()) {
      findDemoFiles(filePath, fileList);
    } else if (file.endsWith('.demo.tsx')) {
      // Get relative path from rootDir
      const relativePath = path.relative(rootDir, filePath);
      fileList.push(relativePath);
    }
  });

  return fileList;
}

/**
 * Build the registry file
 */
async function buildRegistry() {
  const contentDir = path.join(rootDir, 'content');

  if (!fs.existsSync(contentDir)) {
    console.error('âŒ Content directory not found!');
    process.exit(1);
  }

  const demoFiles = findDemoFiles(contentDir);

  console.log('ğŸ“‘ Building demo registry...');

  let index = `// @ts-nocheck
// This file is autogenerated by scripts/build-registry.mjs
// Do not edit this file directly.
import dynamic from 'next/dynamic';

export const registry = {`;

  for (const item of demoFiles) {
    const name = path.basename(item, '.demo.tsx');
    const importPath = item.replace(/\\/g, '/').replace('.tsx', '');

    // Read file contents and inline as source string (useful for code tabs)
    const fullPath = path.join(rootDir, item);
    let fileContent = '';
    try {
      fileContent = fs.readFileSync(fullPath, 'utf8');
    } catch (err) {
      console.warn(`âš ï¸ Could not read file content for ${fullPath}: ${err}`);
    }

    index += `
  '${name}': {
    name: '${name}',
    demo: dynamic(() => import('@/${importPath}')),
    file: '${item.replace(/\\/g, '/')}',
    source: ${JSON.stringify(fileContent)},
  },`;
  }

  index += `
} as const;

export type RegistryKey = keyof typeof registry;
`;

  const registryDir = path.join(rootDir, '.registry');
  const registryFile = path.join(registryDir, 'demos.tsx');
  const jsonFile = path.join(registryDir, 'demos.json');

  // Ensure directory exists
  if (!fs.existsSync(registryDir)) {
    fs.mkdirSync(registryDir, { recursive: true });
  }

  fs.writeFileSync(registryFile, index);

  // Also write JSON with only source data (no dynamic imports)
  const jsonData = {};
  for (const item of demoFiles) {
    const name = path.basename(item, '.demo.tsx');
    const fullPath = path.join(rootDir, item);
    let fileContent = '';
    try {
      fileContent = fs.readFileSync(fullPath, 'utf8');
    } catch (err) {
      console.warn(`Could not read file content for ${fullPath}: ${err}`);
    }

    jsonData[name] = {
      name,
      file: item.replace(/\\/g, '/'),
      source: fileContent,
    };
  }

  fs.writeFileSync(jsonFile, JSON.stringify(jsonData, null, 2));

  console.log(`âœ… Successfully built ${demoFiles.length} registry items!`);
  console.log(`Registry file: ${registryFile}`);
  console.log(`JSON file:     ${jsonFile}\n`);
}

buildRegistry().catch(err => {
  console.error('âŒ Error building registry:', err);
  process.exit(1);
});
